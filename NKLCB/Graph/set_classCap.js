// 회장뽑기(플로이드-와샬 응용)
// 월드컵축구의 응원을 위한 모임에서 회장을 선출하려고 한다. 
// 이모임은 만들어진지 얼마 되지 않았기 때문에 회원사이에 서로 모르는 사람도 있지만, 
// 몇 사람을 통하면 서로 모두 알 수 있다.
// 각 회원은 다른 회원들과 가까운 정도에 따라 점수를 받게 된다.
// 예를 들어 어느 회원이 다른 모든 회원과 친구이면, 이 회원의 점수는 1점이다. 
// 어느 회원의 점수가 2점이면, 다른 모든 회원이 친구이거나, 친구의 친구임을 말한다. 
// 또한, 어느 회원의 점수가 3점이면, 다른 모든 회원이 친구이거나, 친구의 친구이거나, 친국의 친구의 친구임을 말한다.
// 4점, 5점등은 같은 방법으로 정해진다.
// 각 회원의 점수를 정할 때 주의할 점은 어떤 두 회원이 친구 사이이면서 동시에 친구의 친구 사이이면, 
// 이 두 사람은 친구사이라고 본다. 회장은 회원들 중에서 점수가 가장 작은 사람이 된다.
// 회장의 점수와 회장이 될 수 있는 모든 사람을 찾는 프로그램을 작성하시오.
// ▣ 입력설명
// 매개변수 n에는 회원의 수가 있다.
// 단, 회원의 수는 50명을 넘지 않는다.
// 친구 관계를 나타내는 두 개의 회원번호가 순서쌍으로 있는 정보가 edges에 주어진다.
// ▣ 출력설명
// 회장 후보의 점수와 회장후보 수를 반환한다.
// ▣ 매개변수 형식 1
// 5, [[1, 2], [2, 3], [3, 4], [4, 5], [2, 4], [5, 3]]
// ▣ 반환값 형식 1
// [2, 3]
function solution(n, edges) {
    let answer = [];
    let dy = Array.from(Array(n + 1), () => Array(n + 1).fill(100));
    let dist = Array.from({ length: n + 1 }, () => 0);
    for (let i = 1; i <= n; i++) dy[i][i] = 0;
    for (let [a, b] of edges) {
        dy[a][b] = 1;
        dy[b][a] = 1;
    }
    for (let k = 1; k <= n; k++) {
        for (let i = 1; i <= n; i++) {
            for (let j = 1; j <= n; j++) {
                dy[i][j] = Math.min(dy[i][j], dy[i][k] + dy[k][j]);
            }
        }
    }
    let score = 100;
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= n; j++) {
            if (i === j) continue;
            dist[i] = Math.max(dist[i], dy[i][j]); //dist[i]에 max값이 들어감
        }
        score = Math.min(score, dist[i]); //매 회원들 중에 가장 작은 값. 회장 후보가 되는 점수
    }
    answer.push(score);
    let cnt = 0;
    for (let i = 1; i <= n; i++) if (dist[i] === score) cnt++;
    answer.push(cnt);
    return answer;
}

console.log(solution(5, [[1, 2], [2, 3], [3, 4], [4, 5], [2, 4], [5, 3]]));