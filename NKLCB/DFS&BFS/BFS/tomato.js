// 토마토(BFS)
// 현수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다.
// 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.
// 창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 
// 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 
// 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 
// 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다.
// 현수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.
// 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.
// ▣ 입력설명
// 매개변수 board에 하나의 상자에 저장된 토마토들의 정보가 주어집니다. 
// 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.
// ▣ 출력설명
// 여러분은 토마토가 모두 익을 때까지의 최소 날짜를 반환해야 합니다. 
// 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 
// 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.
// ▣ 매개변수 형식 1
// [[0, 0, -1, 0, 0, 0], [0, 0, 1, 0, -1, 0], [0, 0, -1, 0, 0, 0], [0, 0, 0, 0, -1, 1]]
// ▣ 반환값 형식 1
// 4

function solution(board) {
    let answer = 0;
    let n = board.length;
    let m = board[0].length;
    let dx = [-1, 0, 1, 0];
    let dy = [0, 1, 0, -1];
    let dist = Array.from(Array(n), ()=> Array(m).fill(0));
    let queue = [];

    function BFS() {
        while(queue.length) {
            let curr = queue.shift();
            for(let j = 0; j < 4; j++) { //현재 지점에서 4방향 모두 탐색하기
                let nx = curr[0]+dx[j]; 
                let ny = curr[1]+dy[j];
                if(nx >= 0 && nx < n && ny >= 0 && ny < m && board[nx][ny] == 0) { //익을 토마토가 있다면
                    board[nx][ny] = 1; //익었다!
                    dist[nx][ny] = dist[curr[0]][curr[1]]+1; //영향받은 위치의 토마토가 익은 날짜 dist배열에 입력.
                    answer = dist[nx][ny];
                    queue.push([nx,ny]);
                }
            }
        }
    }

    for(let i = 0; i < n; i++) {
        for(let j = 0; j < m; j++) {
            if(board[i][j] === 1) {
                queue.push([i, j]); //이미 익어있는 애 주위만 보면 됨
            }
        }
    }
    BFS();
    for(let k = 0; k < n; k++) {
        for(let l = 0; l < m; l++) {
            if(board[k][l] === 0) { //0인 애가 하나라도 남아있으면 return -1
                return -1;
            }
        }
    }
    return answer;
}

console.log(solution([
    [0, 0, -1, 0, 0, 0], 
    [0, 0, 1, 0, -1, 0], 
    [0, 0, -1, 0, 0, 0], 
    [0, 0, 0, 0, -1, 1]]));

console.log(solution([
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1]]));