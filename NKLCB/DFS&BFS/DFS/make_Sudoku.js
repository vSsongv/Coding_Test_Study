// 스도쿠(DFS 활용)
// 스도쿠는 9×9 크기의 보드가 있을 때, 각 행과 각 열, 그리고 9개의 3×3 크기의 보드에 1부터 9까지의 숫자가 중복 없이 나타나도록 보드를 채우는 퍼즐이다.
// 1 2 3 4 5 6 7 8 9
// 4 5 6 7 8 9 1 2 3
// 7 8 9 1 2 3 4 5 6
// 2 1 4 3 6 5 8 9 7
// 3 6 5 8 9 7 2 1 4
// 8 9 7 2 1 4 3 6 5
// 5 3 1 6 4 2 9 7 8
// 6 4 2 9 7 8 5 3 1
// 9 7 8 5 3 1 6 4 2
// 위 그림은 스도쿠를 정확하게 풀어낸 것이다. 
// 각 행에 1부터 9까지의 숫자가 중복 없이 나오고, 각 열에 1부터 9까지의 숫자가 중복 없이 나오고, 
// 각 3×3짜리 사각형(9개이며, 위에서 색깔로 표시되었다)에 1부터 9까지의 숫자가 중복 없이 한 번씩 나오기 때문이다.
// 완성되지 않은 스도쿠 퍼즐이 주어졌을 때, 스도쿠를 정확하게 완성하는 프로그램을 작성하세요.
// ▣ 입력설명
// board매개변수에 9*9 보드정보가 주어집니다. 아직 숫자가 채워지지 않은 칸은 0으로 표시됩니다.
// ▣ 출력설명
// 완성한 스도쿠를 반환합니다. 답이 여러 개 있다면 그 중 오름차순으로 제일 먼저 발견된 것을 반환하면 됩니다. 
// 즉, 81자리의 수가 제일 작은 경우로 반환하는 것입니다.
// ▣ 매개변수 형식 1
// [[0, 2, 3, 0, 5, 0, 7, 8, 9], [0, 5, 6, 0, 8, 9, 1, 0, 3], [0, 8, 9, 1, 0, 3, 0, 5, 6], [0,
// 1, 0, 0, 6, 0, 8, 9, 0], [3, 0, 5, 0, 9, 7, 0, 1, 4], [0, 9, 7, 0, 1, 0, 0, 6, 5], [5, 3, 0,
// 6, 0, 2, 9, 7, 8], [6, 0, 2, 9, 0, 8, 5, 3, 1], [9, 0, 8, 0, 3, 0, 6, 0, 2]]
// ▣ 반환값 형식 1
// [[1, 2, 3, 4, 5, 6, 7, 8, 9], [4, 5, 6, 7, 8, 9, 1, 2, 3], [7, 8, 9, 1, 2, 3, 4, 5, 6], [2,
// 1, 4, 3, 6, 5, 8, 9, 7], [3, 6, 5, 8, 9, 7, 2, 1, 4], [8, 9, 7, 2, 1, 4, 3, 6, 5], [5, 3, 1,
// 6, 4, 2, 9, 7, 8], [6, 4, 2, 9, 7, 8, 5, 3, 1], [9, 7, 8, 5, 3, 1, 6, 4, 2]]

function solution(board) {
    let answer = 0;
    let checkBoard = Array.from(Array(2), ()=>Array(81).fill(0));
    let row = Array.from(Array(10), ()=>Array(10).fill(0));
    let col = Array.from(Array(10), ()=>Array(10).fill(0));
    let group = Array.from(Array(10), ()=>Array(10).fill(0));
    let cnt = 0;

    for(let i = 0; i < 9; i++) {
        for(let j = 0; j < 9; j++) {
            if(board[i][j] === 0) {
                checkBoard[0][cnt] = i;
                checkBoard[1][cnt++] = j;
            }
            else {
                row[i][board[i][j]] = 1;
                col[j][board[i][j]] = 1;
                group[find(i, j)][board[i][j]] = 1;
            }
        }
    }
    let flag = false;
    DFS(0);
    function find(x, y) {
        return parseInt(x/3)*3 + parseInt(y/3);
    }

    function DFS(L) {
        if(flag) return;
        if(L === cnt) {
            answer = board.map(v => v.slice());
            flag = true;
        }
        else {
            let xx = checkBoard[0][L];
            let yy = checkBoard[1][L];
            let gg = find(xx, yy);
            for(let i = 1; i <= 9; i++) {
                if(row[xx][i] === 0 && col[yy][i] === 0 && group[gg][i] === 0) {
                    row[xx][i] = col[yy][i] = group[gg][i] = 1;
                    board[xx][yy] = i;
                    DFS(L+1);
                    board[xx][yy] = 0;
                    row[xx][i] = col[yy][i] = group[gg][i] = 0;
                }
            }
        }
    }
    return answer;
}

console.log(solution([[0, 2, 3, 0, 5, 0, 7, 8, 9], [0, 5, 6, 0, 8, 9, 1, 0, 3], [0, 8, 9, 1, 0, 3, 0, 5, 6], [0,
    1, 0, 0, 6, 0, 8, 9, 0], [3, 0, 5, 0, 9, 7, 0, 1, 4], [0, 9, 7, 0, 1, 0, 0, 6, 5], [5, 3, 0,
    6, 0, 2, 9, 7, 8], [6, 0, 2, 9, 0, 8, 5, 3, 1], [9, 0, 8, 0, 3, 0, 6, 0, 2]]));