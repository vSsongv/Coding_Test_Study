// 가방문제(냅색 알고리즘)
// 최고 11kg의 무게를 저장할 수 있는 가방이 있다.
// 그리고 각각 5kg, 3kg, 6kg, 4kg의 무게를 가진 4종류의 보석이 있다.
// 이 보석들의 가치는 각각 12, 8, 14, 7이다.
// 이 보석을 가방에 담는데 11kg를 넘지 않으면서 최대의 가치가 되도록 하려면 어떻게 담아야 할까요?
// 각 종류별 보석의 개수는 무한이 많다. 한 종류의 보석을 여러 번 가방에 담을 수 있다는 뜻입니다.
// ▣ 입력설명
// 매개변수 nums에 각 보석의 무게와 가치가 순서쌍을 주어집니다.
// 매개변수 m에 가방에 저장할 수 있는 무게가 주어집니다.
// 가방의 저장무게는 1000kg을 넘지 않는다. 보석의 개수는 30개 이내이다.
// ▣ 출력설명
// 가방에 담을 수 있는 보석의 최대가치를 출력한다.
// ▣ 입력예제 1
// [[5, 12], [3, 8], [6, 14], [4, 7]], 11
// ▣ 출력예제 1
// 28
// 해설 : 5g 1개, 3g 2개를 선택해서 28가치가 최대이다.

function solution(nums, m) {
  let answer = 0;
  let dp = Array(m + 1).fill(0);
  //dp[i]의 값은 i의 무게 만큼 가방을 채웠을 때 가능한 최대 가치.
  for (let i = 0; i < nums.length; i++) {
    for (let j = nums[i][0]; j <= m; j++) {
      //지금 넣을 무게를 m보다 작을 때까지 최대로 넣어보기
      dp[j] = Math.max(dp[j], dp[j - nums[i][0]] + nums[i][1]); //현재 축적된 가치와 새로운 가치를 비교해서 큰 값으로 update.
    }
  }
  answer = dp[m];
  return answer;
}

console.log(
  solution(
    [
      [5, 12],
      [3, 8],
      [6, 14],
      [4, 7],
    ],
    11,
  ),
);
