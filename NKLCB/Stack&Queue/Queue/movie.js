// 영화 관람(Stack)
// 수요일은 오후에 영화를 보는 날입니다. 현수네 반 N명의 학생들은 영화를 보기 위해 학교 강당에 모였습니다.
// 강당의 좌석은 영화관처럼 계단형이 아니라 평평한 바닥에 의자가 일렬로 놓여진 상태입니다.
// 앉는 순서는 제일 앞자리부터 반 번호순(1번 부터)으로 앉습니다.
// 그런데 영화시청에 문제가 생겼습니다. 만약 앞자리에 앉은 키가 큰 학생이 앉으면 
// 그 학생보다 앉은키가 작은 뒷자리 학생은 스크린이 보이지 않습니다.
// N명의 학생들의 앉은 키 정보가 주어지면 각 학생들의 최초 시야를 가려 
// 영화관람을 불가능하게 하는 학생들을 찾고 싶습니다.
// 예를 들어 N=5이고 다음과 같이 1번 학생부터 앞자리에 차례대로 앉았다면
// 50 57 52 53 51
// 1번 학생(50)은 제일 앞자리이므로 최초 시청방해 학생이 없습니다.
// 2번 학생(57)은 시청 방해학생이 없습니다.
// 3번 학생(52)의 최초 시청 방해학생은 2번(57) 학생입니다.
// 4번 학생(53)의 최초 시청 방해학생은 2번(57) 학생입니다.
// 5번 학생(51)의 최초 시청 방해학생은 4번(53) 학생입니다.
// N명의 앉은 키 정보가 주어지면 각 학생들의 최초 시청을 방해하는 학생들의 번호를 출력하는 프로그램을 장성하세요.
// ▣ 입력설명
// 매개변수 nums에 N(3<=N<=200,000)명의 앉은 키 정보(1부터 100,000이하)가 1번 학생부터반 번호순으로 주어집니다.
// ▣ 출력설명
// 1번 학생부터 N번 학생 순으로 자기 자신을 최초로 시청방해하는 학생의 번호를 배열형태로 반환합니다.
// ▣ 매개변수 형식 1
// [50, 57, 52, 53, 51]
// ▣ 반환값 형식 1
// [0, 0, 2, 2, 4]
// ▣ 매개변수 형식 2
// [50, 46, 55, 76, 65, 50, 55, 53, 55, 50]
// ▣ 반환값 형식 2
// [0, 1, 0, 0, 4, 5, 5, 7, 5, 9]

function solution(nums) {
    let stack = [];
    let answer = new Array(nums.length).fill(0); //배열을 만든 후 모두 0으로 초기화
    
    for(let i = nums.length-1; i >= 0 ; i--) { //맨 뒤에서부터 넣어주고,
        while(stack.length && nums[i] > nums[stack[stack.length-1]]) { //지금 앉을 학생이 stack의 맨 뒤의 학생보다 크면, 현재 stack에 있는 학생의 앞을 가림!
            answer[stack[stack.length-1]] = i+1; //answer의 같은 index에 방금 앉을 학생 index+1을 넣어준다.
            stack.pop(); //stack에 있는 학생은 처음으로 가리는 사람이 누군지 알았기 때문에 삭제해준다.        
        }
        stack.push(i); //방금 들어온 애 넣어주기.
    }
    return answer;
}

console.log(solution([50, 57, 52, 53, 51]));
console.log(solution([50, 46, 55, 76, 65, 50, 55, 53, 55, 50]));