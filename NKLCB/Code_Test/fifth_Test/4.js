// 철수와 영희는 서로의 비밀편지를 암호화해서 서로 주고받기로 했다. 그래서 서로 어떻게 암호화를 할 것인지 의논을 하고 있다.
// 영희 : 우리 알파벳 A에는 1로, B에는 2로 이렇게 해서 Z에는 26을 할당하여 번호로 보내기로 하자.
// 철수 : 정말 바보같은 생각이군!! 생각해 봐!! 만약 내가 “BEAN"을 너에게 보낸다면 그것을 암호화하면 25114이잖아!! 그러면 이것을 다시 알파벳으로 복원할 때는 많은 방법이 존재하는 데 어떻게 할건데... 이것을 알파벳으로 바꾸면 BEAAD, YAAD, YAN, YKD 그리고 BEKD로 BEAN말고도 5가지나 더 있군.
// 당신은 위와 같은 영희의 방법으로 암호화된 코드가 주어지면 그것을 알파벳으로 복원하는데 얼마나 많은 방법인 있는지 구하세요.

// ▣ 입력설명
// 매개변수 s에 암호화된 코드가 문자열형태로 전달됩니다. (코드는 0으로 시작하지는 않는다, 코드의 길이는 최대 100이다)

// ▣ 출력설명
// 입력된 코드를 알파벳으로 복원하는데 몇 가지의 방법이 있는지 그 가지수를 반환합니다.

// ▣ 입력형식 1
// "25114"

// ▣ 반환값 형식 1
// 6

function solution(s) {
  let L = 0;
  let dp = Array(120).fill(0);
  function DFS(L) {
    if (s[L] === '0') return 0;
    if (dp[L] > 0) return dp[L];
    if (L === s.length - 1 || L === s.length) return 1;
    let answer = DFS(L + 1);
    let tmp = parseInt(s.substring(L, L + 2));

    if (tmp <= 26) answer += DFS(L + 2);
    return (dp[L] = answer);
  }
  return DFS(0);
}

console.log(solution('25114')); //6
