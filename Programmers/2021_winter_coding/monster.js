// 게임에서 몬스터를 잡아 경험치를 획득하려 합니다. 게임에는 다양한 몬스터가 있으며, 몬스터 별로 획득할 수 있는 경험치도 다양합니다. 이 중에서 1초당 가장 많은 경험치를 획득할 수 있는 몬스터를 잡으려 합니다.

// 본 문제에서는 플레이어의 [체력, 공격력, 방어력]과 각 몬스터의 [이름, 경험치, 체력, 공격력, 방어력]이 주어집니다.
// 게임을 진행하는 방식은 다음과 같습니다.

// 플레이어가 몬스터를 공격합니다. 몬스터의 체력이 (플레이어의 공격력 - 몬스터의 방어력) 만큼 감소합니다.
// 1-1. (플레이어의 공격력 - 몬스터의 방어력)이 0 이하인 경우 몬스터의 체력이 감소하지 않습니다.
// 몬스터의 체력이 0 이하가 되면 몬스터가 죽고, 전투가 종료됩니다.
// 몬스터가 플레이어를 공격합니다. 플레이어의 체력이 (몬스터의 공격력 - 플레이어의 방어력) 만큼 감소합니다.
// 3-1. (몬스터의 공격력 - 플레이어의 방어력)이 0 이하인 경우 플레이어의 체력이 감소하지 않습니다.
// 플레이어의 체력이 0 이하가 되면 플레이어가 죽고, 전투가 종료됩니다.
// 플레이어가 죽지 않았다면 몬스터로부터 받은 피해를 모두 회복합니다. 즉 처음 체력으로 돌아옵니다.
// 전투가 종료될 때까지 1 ~ 5를 반복하며, 몬스터를 잡으면 해당 몬스터가 주는 경험치를 획득합니다. 만약 전투가 영원히 종료되지 않거나, 플레이어가 먼저 죽는다면 해당 몬스터를 잡을 수 없다고 판단합니다.

// 플레이어가 몬스터를 한 번 공격하는데 1초가 걸리며, 몬스터가 플레이어를 공격하거나 플레이어가 회복 스킬을 사용하는데 걸리는 시간은 없다고 가정합니다. 또, 플레이어는 한 번에 한 마리의 몬스터 하고만 전투를 진행할 수 있습니다.

// 플레이어의 정보를 뜻하는 문자열 character, 몬스터들의 정보가 담긴 문자열 배열 monsters가 주어질 때, 1초당 가장 많은 경험치를 주는 몬스터의 이름을 return 하도록 solution 함수를 완성해주세요.

// 만약 1초당 가장 많은 경험치를 주는 몬스터가 여러 마리라면, 그중 한 마리를 잡았을 때 가장 많은 경험치를 주는 몬스터를 return 합니다. 주는 경험치도 같다면 monsters 배열에서 먼저 주어진(더 작은 인덱스를 가지는) 몬스터를 return 합니다.

// 제한사항
// character은 "A B C"의 형태입니다.
// A는 플레이어의 체력입니다.
// 1 ≤ A ≤ 100
// B는 플레이어의 공격력입니다.
// 0 ≤ B ≤ 100
// C는 플레이어의 방어력입니다.
// 0 ≤ C ≤ 100
// 1 ≤ monsters의 길이 ≤ 100
// monsters의 원소는 "A B C D E"의 형태입니다.
// A는 몬스터의 이름을 뜻하며, 영어 대문자 혹은 소문자로만 이루어져 있습니다.
// 1 ≤ A의 길이 ≤ 100
// B는 몬스터가 주는 경험치입니다.
// 1 ≤ B ≤ 100
// C는 몬스터의 체력입니다.
// 1 ≤ C ≤ 100
// D는 몬스터의 공격력입니다.
// 0 ≤ D ≤ 100
// E는 몬스터의 방어력입니다.
// 0 ≤ E ≤ 100
// 몬스터의 이름은 대소문자를 구분합니다. (예를 들어 "Dragon" 과 "dRagoN"은 서로 다른 몬스터입니다).
// 이름이 동일한 몬스터가 중복해서 들어있는 경우는 없습니다.
// 정답이 빈 문자열인 경우는 없습니다.
// 입출력 예
// character	monsters	result
// "10 5 2"	["Knight 3 10 10 3","Wizard 5 10 15 1","Beginner 1 1 15 1"]	"Beginner"
// 입출력 예 설명
// 입출력 예 #1

// 플레이어의 체력은 10, 플레이어의 공격력은 5, 플레이어의 방어력은 2입니다.

// Knight의 경험치는 3, 체력은 10, 공격력은 10, 방어력은 3입니다.
// 플레이어와 Knight의 전투는 다음과 같이 진행됩니다.

// 1. 플레이어가 Knight를 공격해 Knight의 체력이 5 - 3 = 2만큼 감소합니다. Knight의 남은 체력은 8입니다.
// 2. Knight가 플레이어를 공격해 플레이어의 체력이 10 - 2 = 8만큼 감소합니다. 플레이어의 남은 체력은 2입니다.
// 3. 플레이어가 피해를 모두 회복하여 체력이 다시 10이 됩니다. 
// 4. 플레이어가 Knight를 공격합니다. Knight의 남은 체력은 6입니다.
// 5. Knight가 플레이어를 공격합니다. 플레이어의 남은 체력은 2입니다.
// 6. 플레이어가 피해를 모두 회복하여 체력이 다시 10이 됩니다.
// 7. 플레이어가 Knight를 공격합니다. Knight의 남은 체력은 4입니다.
// 8. Knight가 플레이어를 공격합니다. 플레이어의 남은 체력은 2입니다.
// 9. 플레이어가 피해를 모두 회복하여 체력이 다시 10이 됩니다.
// 10. 플레이어가 Knight를 공격합니다. Knight의 남은 체력은 2입니다.
// 11. Knight가 플레이어를 공격합니다. 플레이어의 남은 체력은 2입니다.
// 12. 플레이어가 피해를 모두 회복하여 체력이 다시 10이 됩니다.
// 13. 플레이어가 Knight를 공격합니다. Knight의 남은 체력은 0입니다. Knight가 죽으면서 전투가 종료됩니다.
// 플레이어가 Knight에게 총 5번의 공격을 했으므로 총 5초가 지났습니다.
// Knight를 사냥할 때는 5초 동안 경험치 3을 획득할 수 있습니다.

// Wizard의 경험치는 5, 체력은 10, 공격력은 15, 방어력은 1입니다.
// 플레이어와 Wizard의 전투는 다음과 같이 진행됩니다.

// 1. 플레이어가 Wizard를 공격해 Wizard의 체력이 5 - 1 = 4만큼 감소합니다. Wizard의 남은 체력은 5입니다.
// 2. Wizard가 플레이어를 공격해 플레이어의 체력이 15 - 2 = 13만큼 감소합니다. 플레이어의 남은 체력이 -3, 즉 0 이하가 되어 플레이어가 죽고 전투가 종료됩니다.
// 따라서, 플레이어는 Wizard에게 죽게 됩니다. Wizard를 잡을 수 없으므로 경험치도 획득할 수 없습니다.

// Begginer의 경험치는 1, 체력은 1, 공격력은 15, 방어력은 1입니다.

// 1. 플레이어가 Beginner를 공격해 Beginner의 체력이 5 - 1 = 4만큼 감소합니다. Begginer의 남은 체력이 -3, 즉 0 이하가 되어 Begginer가 죽고 전투가 종료됩니다.
// 플레이어가 Begginer에게 총 1번의 공격을 했으므로 총 1초가 지났습니다.
// Begginer를 사냥할 때는 1초 동안 경험치 1을 획득할 수 있습니다.

// 몬스터 세 마리에 대해 1초당 획득 경험치를 정리하면 다음과 같습니다.

// 몬스터 이름	몬스터를 잡는데 걸리는 시간(초)	획득 경험치	1초당 획득 경험치

// Knight	5	3	3/5
// Wizard	(잡을 수 없음)	0	0
// Beginner	1	1	1
// 따라서 Begginer를 잡으면 1초당 가장 많은 경험치를 획득할 수 있습니다.


//플레이어 -> 몬스터 공격 몬스터 체력(플레이어의 공격력 - 몬스터의 방어력
//몬스터 -> 플레이어 공격 플레이어 체력(몬스터의 공격력 - 플레이어의 방어력
//플레이어 체력 0 -> 전투 끝 or 플레이어 체력 전부 회복

//몬스터가 죽으면 경험치 획득
//1초당 획득 경험치 : 경험치 / 공격한시간 이 제일 큰 몬스터 이름 return
//1초당 획득 경험치 같으면 주는 경험치가 큰 몬스터 이름 return
//주는 경험치 같으면 index 빠른애 return
//turn 이 무한히 반복되면 해당 몬스터는 못 잡음 
//플레이어가 먼저 죽으면 해당 몬스터는 못 잡음

function solution(character, monsters) {
    var answer = '';
    let candidates = {};
    let sameCadi = {};
    let forComp = {};
    let points = {};
    for (let i = 0; i < monsters.length; i++) {
        let player = character.split(' ');
        let pHP = player[0];
        let pHPb = pHP;
        let pAt = player[1];
        let pGd = player[2];
        let monster = monsters[i].split(' ');
        let mName = monster[0];
        let mPt = monster[1];
        let mPtb = mPt;
        let mHP = monster[2];
        let mAt = monster[3];
        let mGd = monster[4];
        let turn = 0;
        while (pHP > 0 && (pAt - mGd > 0 && mAt - pGd > 0)) {
            turn += 1;
            mHP -= (pAt - mGd);
            if (mHP <= 0) break;
            pHP -= (mAt - pGd);
            if (pHP > 0) pHP = pHPb;
        }
        if (pHP > 0 && mHP <= 0) {
            points[mName] = mPt / turn; //플레이어가 죽어서 끝난거면 경험치 획득 불가
            forComp[mName] = mPt;
        }
    }
    let max = 0;
    for (let [key, val] of Object.entries(points)) {
        if (max < val) max = val;
        if (val in candidates) candidates[val].push(key);
        else {
            candidates[val] = [];
            candidates[val].push(key);
        }
    }
    if (candidates[max].length === 1) return candidates[max][0];
    else {
        let maxP = 0;
        for (let c of candidates[max]) {
            if (maxP < forComp[c]) {
                maxP = forComp[c];
                answer = c;
            }
        }
        return answer;
    }
}
// console.log(solution("10 5 2", ["Knight 3 10 10 3", "Wizard 5 10 15 1", "Beginner 1 1 15 1"]));
// console.log(solution("10 5 2", ["Knight 3 10 10 3", "Wizard 5 10 15 1", "Beginner 3 10 10 3"]));
console.log(solution("10 5 5", ["Knight 3 10 5 5", "Wizard 5 10 15 1", "Beginner 3 10 10 3"]));