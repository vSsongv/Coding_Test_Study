// 문제 설명
// 다양한 맛이 섞여 있는 n x n 행렬 모양의 케이크가 있습니다.이 케이크를 가로 및 세로 방향으로 잘라서 여러 사람들과 나눠 먹으려고 합니다.

//     cake7.png

// 위 그림은 6 x 6 크기의 케이크를 가로로 3번, 세로로 2번 자른 예시입니다.빨간색 선이 케이크를 자른 위치를 나타내고, 격자 안의 대문자 알파벳은 케익의 맛을 나타냅니다.위의 그림에서는 6가지(A, C, X, Z, T, U)의 서로 다른 알파벳이 나타났으므로, 이 케이크는 6가지 맛이 섞여 있습니다.
// 당신은 잘린 여러 개의 케이크 조각 중에서, 가장 다양한 맛이 섞인 케이크 조각을 고르려고 합니다.위의 예에서, 좌측 하단에 위치한 조각(A, T, X, U)과 우측 중간에 위치한 조각(A, C, X, Z, Z, X)은 모두 4개의 맛이 섞여 있습니다.

// 케이크의 정보를 나타내는 문자열 배열 cakes, 가로로 자르는 위치를 나타내는 정수 배열 cut_rows, 세로로 자르는 위치를 나타내는 정수 배열 cut_columns가 매개변수로 주어집니다.이때, 가장 다양한 맛을 포함한 케이크 조각은 몇 개의 맛을 포함하고 있는지를 구해서 return 하도록 solution 함수를 완성해주세요.

//     제한사항
// cakes의 길이(=원소의 개수)는 2 이상 50 이하입니다.
// cakes의 각 원소는 길이가 2 이상 50 이하인 문자열입니다.
// 케이크는 정사각형 모양이므로, cakes의 원소 개수와 cakes의 원소가 되는 문자열의 길이는 항상 같습니다.
// cakes의 각 원소는 대문자 알파벳으로만 이루어져 있습니다.즉, 케이크는 최대 26가지 맛이 섞여 있습니다.
// cut_rows의 길이는 1 이상 49 이하입니다.
// cut_rows의 각 원소는 가로로 자를 행의 번호를 나타냅니다.
// cut_rows의 원소가 r이라면, 케이크의 r번째 행과 r + 1번째 행의 경계 부분을 자른다는 것을 의미합니다.
// 중복된 원소나 케이크 크기를 벗어나는 잘못된 값은 입력으로 주어지지 않습니다.
// cut_rows의 원소들은 항상 오름차순으로 정렬되어 있습니다.
// cut_columns의 길이는 1 이상 49 이하입니다.
// cut_columns의 각 원소는 세로로 자를 열의 번호를 나타냅니다.
// cut_columns의 원소가 c이라면, 케이크의 c번째 열과 c + 1번째 열의 경계 부분을 자른다는 것을 의미합니다.
// 중복된 원소나 케이크 크기를 벗어나는 잘못된 값은 입력으로 주어지지 않습니다.
// cut_columns의 원소들은 항상 오름차순으로 정렬되어 있습니다.
// 입출력 예
// cakes	cut_rows	cut_columns	result
// ["AAAACX", "AAAACX", "AAAACX", "ZZZZZX", "ATTTTX", "XUUUUU"][1, 2, 4][2, 3]	4
// ["KKKK", "KKKK", "KKKK", "FGHI"][2, 3][2]	2
// ["KKK", "KKK", "KKK"][2][2]	1
// 입출력 예 설명
// 입출력 예 #1
// 문제 예시와 같습니다.가장 다양한 맛이 섞인 케이크 조각은 4가지 맛을 포함하고 있습니다.

// 입출력 예 #2
// cake8.png
// 최하단에 위치한 두 개의 케이크 조각이 모두 2가지 맛을 포함하고 있습니다.

// 입출력 예 #3
// cake9.png
// 모든 케이크 조각들이 1가지 맛을 포함하고 있습니다.